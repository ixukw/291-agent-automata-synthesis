
// pos = [r,c] = [y,x]

int t = 2;
int m = 1;
int n = 2;



harness int[2] transition(int[n][m] grid, int[2] pos, int[2] true_next_pos) {
  int a = 0;
  int b = ??;
  //int action = 0;

  if (0) {
    a = ??;
    b = ??;
    return {0,1}; //moveLeft(pos)
  }
  if (1){
    a = ??;
    b = ??;
    return {0,-1}; //moveRight(pos)
  }
  // int[2] change = action_map(action);
  // int[2] next_pos = {pos[0] + change[0], pos[1]+change[1]};
  // next_pos[0] = pos[0] + change[0];
  // next_pos[1] = pos[1] + change[1];
  //assert(next_pos == true_next_pos);

  
  //... 
  //return action;
}

void check(int[n][m] grid, int[2] pos, int[2] next_pos, int[2] true_action){
  int[2] synthesized_action = transition(grid, pos, next_pos);
  
  assert(synthesized_action == true_action);
}

void check_all(int[n][m][t] grids, int[2][t] pos, int[2][t] actions) {
  //for (int i=1; i<t; i++) {
  //  check(grids[i], pos[i-1], pos[i], actions[i]);
  //}
  check(grids[0], pos[0], pos[1], actions[1]);
  //check(grids[1], pos[1], pos[2], actions[2]);
}

harness void main() {

  int t = 2;
  int m = 1;
  int n = 2;

  int[n][m][t] grids = {{{1,0}}, {{0,1}}}; 
  
  int[2][t] pos = {{0,0},{0,1}};
  int[2][t] actions = {{0,0}, {0,1}};
  check_all(grids, pos, actions);
}