
// pos = [r,c] = [y,x]

int t = 3;
int m = 1;
int n = 2;

int[2] action_map(int action) { // id 1
  int[2] a;
  a[0] = 0;
  a[1] = 0;
  if(action == 1) { // move left
    a[0] = 0;
    a[1] = -1;
  }
  else if (action == 2) { // right
    a[0] = 0;
    a[1] = 1;
  }
  else if (action == 3) { // up
    a[0] = -1;
    a[1] = 0;
  }
  else if (action == 4) { // down
    a[0] = 1;
    a[1] = 0;
  }
  return a;
}

harness int transition(int[][] grid, int[] pos, int[] true_next_pos) {
  int a = ??;
  int b = ??;
  int action = 0;

  if (??) {
    action = 1; //moveLeft(pos)
  }
  else if (??){
    action = 2; //moveRight(pos)
  }
  int[2] change = action_map(action);
  int[2] next_pos = {pos[0] + change[0], pos[1]+change[1]};
  // next_pos[0] = pos[0] + change[0];
  // next_pos[1] = pos[1] + change[1];
  assert(next_pos == true_next_pos);

  
  //... 
  return action;
}

void check(int[m][n] grid, int[t] pos, int[t] next_pos, int true_action){
  int synthesized_action = transition(grid, pos, next_pos);
  
  assert(synthesized_action == true_action);
}

void check_all(int[t][m][n] grids, int[t][2] pos, int[t] actions) {
  for (int i=1; i<t; i++) {
    check(grids[i], pos[i-1], pos[i], action[i]);
  }
}

harness void main() {
  int[t][m][n] grids = {{{1,0}}, {{0,1}}, {{1,0}}}; 
  
  int[t][2] pos = {{0,0},{0,1},{0,0}};
  int[t] actions = {0,1,2};
  check_all(grids, pos, actions);
}